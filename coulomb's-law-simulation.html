<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coulomb's Law 3D Simulation - Force Between Two Charges | chartleap</title>
    <meta name="description" content="Do charges ke beech lagne wale force ko interactive tarike se calculate karein. Distance aur charge badal kar Coulomb's force ka asar dekhein.">
    <meta name="keywords" content="coulombs law simulation, electric force calculator, interactive physics experiments, charge interaction 3d">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="canonical" href="https://www.chartleap.online/coulomb's-low-simulation.html" />


    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #f3f4f6;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(17, 24, 39, 0.8);
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(55, 65, 81, 0.5);
            width: 320px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
        }
        .slider-container {
            margin-top: 1rem;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #374151;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
        }
        #q1Slider::-webkit-slider-thumb { background: #ef4444; }
        #q2Slider::-webkit-slider-thumb { background: #3b82f6; }
        .label {
            color: #fff;
            font-family: 'Inter', sans-serif;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h1 class="text-xl font-bold text-center text-gray-100">Coulomb's Law Controls</h1>
        
        <!-- Charge 1 Controls -->
        <div class="slider-container">
            <label for="q1Slider" class="flex justify-between font-medium">
                <span>Charge q1</span>
                <span id="q1Value" class="font-bold text-red-400">5.0 µC</span>
            </label>
            <input type="range" min="-10" max="10" value="5" step="0.1" class="slider mt-2" id="q1Slider">
        </div>
        
        <!-- Charge 2 Controls -->
        <div class="slider-container">
            <label for="q2Slider" class="flex justify-between font-medium">
                <span>Charge q2</span>
                <span id="q2Value" class="font-bold text-blue-400">-5.0 µC</span>
            </label>
            <input type="range" min="-10" max="10" value="-5" step="0.1" class="slider mt-2" id="q2Slider">
        </div>

        <!-- Information Display has been moved to the 3D scene -->
        
        <p class="text-xs text-gray-400 mt-4 text-center">Drag the charges to change their position. Click and drag to rotate the view, and scroll to zoom.</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Basics ---
        let scene, camera, renderer, controls, dragControls, labelRenderer;
        const k = 8.9875517923e9; // Coulomb's constant
        const objects = [];

        // --- Objects ---
        let charge1, charge2, forceArrow1, forceArrow2, distanceLine;
        let q1Label, q2Label, distanceLabel, forceLabel1, forceLabel2;
        
        // --- UI Elements ---
        const q1Slider = document.getElementById('q1Slider');
        const q2Slider = document.getElementById('q2Slider');
        const q1ValueDisplay = document.getElementById('q1Value');
        const q2ValueDisplay = document.getElementById('q2Value');

        // --- Helper Colors ---
        const positiveColor = new THREE.Color(0xff4444);
        const negativeColor = new THREE.Color(0x4488ff);
        const neutralColor = new THREE.Color(0x999999);
        
        function init() {
            // --- Scene ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            // --- Camera ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 7, 10);
            camera.lookAt(0, 0, 0);

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- Label Renderer ---
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 5);
            scene.add(directionalLight);

            // --- Helpers ---
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
            scene.add(gridHelper);
            const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0, 0, 0), new THREE.Vector3(20, 20, 20));
            const boxHelper = new THREE.Box3Helper(box, 0x555555);
            scene.add(boxHelper);

            // --- Charge Objects ---
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            
            const material1 = new THREE.MeshStandardMaterial({ color: positiveColor, emissive: positiveColor, emissiveIntensity: 0.6 });
            charge1 = new THREE.Mesh(sphereGeometry, material1);
            charge1.position.set(-3, 0, 0);
            scene.add(charge1);
            objects.push(charge1);

            const material2 = new THREE.MeshStandardMaterial({ color: negativeColor, emissive: negativeColor, emissiveIntensity: 0.6 });
            charge2 = new THREE.Mesh(sphereGeometry, material2);
            charge2.position.set(3, 0, 0);
            scene.add(charge2);
            objects.push(charge2);

            // --- Create Labels ---
            const q1Div = document.createElement('div');
            q1Div.className = 'label';
            q1Label = new CSS2DObject(q1Div);
            charge1.add(q1Label);
            q1Label.position.set(0, 1.2, 0);

            const q2Div = document.createElement('div');
            q2Div.className = 'label';
            q2Label = new CSS2DObject(q2Div);
            charge2.add(q2Label);
            q2Label.position.set(0, 1.2, 0);

            const distDiv = document.createElement('div');
            distDiv.className = 'label';
            distanceLabel = new CSS2DObject(distDiv);
            scene.add(distanceLabel);

            const force1Div = document.createElement('div');
            force1Div.className = 'label';
            forceLabel1 = new CSS2DObject(force1Div);
            scene.add(forceLabel1);

            const force2Div = document.createElement('div');
            force2Div.className = 'label';
            forceLabel2 = new CSS2DObject(force2Div);
            scene.add(forceLabel2);

            // --- Force Arrows ---
            forceArrow1 = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), charge1.position, 1, 0xffff00);
            scene.add(forceArrow1);
            forceArrow2 = new THREE.ArrowHelper(new THREE.Vector3(-1, 0, 0), charge2.position, 1, 0xffff00);
            scene.add(forceArrow2);

            // --- Distance Line ---
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([charge1.position, charge2.position]);
            distanceLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(distanceLine);

            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            dragControls = new DragControls(objects, camera, renderer.domElement);
            
            dragControls.addEventListener('drag', updateSimulation);
            dragControls.addEventListener('dragstart', () => controls.enabled = false);
            dragControls.addEventListener('dragend', () => controls.enabled = true);

            q1Slider.addEventListener('input', updateSimulation);
            q2Slider.addEventListener('input', updateSimulation);

            window.addEventListener('resize', onWindowResize);
            
            updateSimulation();
            animate();
        }

        function updateSimulation() {
            const q1 = parseFloat(q1Slider.value) * 1e-6; // µC to C
            const q2 = parseFloat(q2Slider.value) * 1e-6; // µC to C

            // --- Update UI ---
            q1ValueDisplay.textContent = `${q1Slider.value} µC`;
            q2ValueDisplay.textContent = `${q2Slider.value} µC`;
            
            // --- Update charge colors and sizes ---
            updateChargeVisuals(charge1, q1);
            updateChargeVisuals(charge2, q2);

            // --- Calculations ---
            const rVec = new THREE.Vector3().subVectors(charge2.position, charge1.position);
            const r = rVec.length();
            const r_hat = rVec.normalize();
            
            // Prevent force from becoming infinite if distance is too small
            if (r < 0.2) {
                distanceLabel.element.textContent = `Distance: ${r.toFixed(2)} m`;
                forceLabel1.element.textContent = 'Force: ∞';
                forceLabel2.element.textContent = 'Force: ∞';
                forceLabel1.position.copy(charge1.position).add(new THREE.Vector3(0,1.5,0));
                forceLabel2.position.copy(charge2.position).add(new THREE.Vector3(0,1.5,0));
                forceArrow1.visible = false;
                forceArrow2.visible = false;
                return;
            }
            
            const forceMagnitude = k * Math.abs(q1 * q2) / (r * r);
            
            // --- Update force arrows ---
            // forceSign = 1 for repulsion, -1 for attraction
            const forceSign = Math.sign(q1 * q2); 
            if (q1 === 0 || q2 === 0) {
                 forceArrow1.visible = false;
                 forceArrow2.visible = false;
            } else {
                 forceArrow1.visible = true;
                 forceArrow2.visible = true;
            }

            // Force on q1
            const forceOn1Dir = r_hat.clone().multiplyScalar(-forceSign);
            forceArrow1.position.copy(charge1.position);
            forceArrow1.setDirection(forceOn1Dir);

            // Force on q2
            const forceOn2Dir = r_hat.clone().multiplyScalar(forceSign);
            forceArrow2.position.copy(charge2.position);
            forceArrow2.setDirection(forceOn2Dir);
            
            // Scale the force for visualization
            const arrowLength = Math.min(Math.sqrt(forceMagnitude) * 0.3, 8);
            forceArrow1.setLength(arrowLength, 0.4, 0.2);
            forceArrow2.setLength(arrowLength, 0.4, 0.2);
            
            // --- Update distance line ---
            distanceLine.geometry.setFromPoints([charge1.position, charge2.position]);
            distanceLine.geometry.verticesNeedUpdate = true;

            // --- Update Labels ---
            q1Label.element.textContent = `${(q1 * 1e6).toFixed(1)} µC`;
            q2Label.element.textContent = `${(q2 * 1e6).toFixed(1)} µC`;
            distanceLabel.element.textContent = `Distance: ${r.toFixed(2)} m`;
            
            // Position of the distance label
            const midpoint = new THREE.Vector3().addVectors(charge1.position, charge2.position).multiplyScalar(0.5);
            distanceLabel.position.copy(midpoint);

            // Force labels
            if (q1 === 0 || q2 === 0 || forceMagnitude < 1e-3) { // Hide label if force is negligible
                forceLabel1.visible = false;
                forceLabel2.visible = false;
            } else {
                const forceText = `Force: ${forceMagnitude.toExponential(2)} N`;
                forceLabel1.element.textContent = forceText;
                forceLabel2.element.textContent = forceText;
                forceLabel1.visible = true;
                forceLabel2.visible = true;
                
                // Position of force labels
                forceLabel1.position.copy(charge1.position).add(forceOn1Dir.clone().multiplyScalar(arrowLength + 0.7));
                forceLabel2.position.copy(charge2.position).add(forceOn2Dir.clone().multiplyScalar(arrowLength + 0.7));
            }
        }
        
        function updateChargeVisuals(chargeMesh, qValue) {
            // Set color
            if (qValue > 0) {
                chargeMesh.material.color.copy(positiveColor);
                chargeMesh.material.emissive.copy(positiveColor);
            } else if (qValue < 0) {
                chargeMesh.material.color.copy(negativeColor);
                chargeMesh.material.emissive.copy(negativeColor);
            } else {
                chargeMesh.material.color.copy(neutralColor);
                chargeMesh.material.emissive.copy(neutralColor);
            }
            
            // Set size
            const scale = 1 + Math.abs(qValue * 1e5) * 0.05; // 1e-6 * 1e5 = 0.1
            chargeMesh.scale.set(scale, scale, scale);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


