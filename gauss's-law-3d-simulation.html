<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gauss's Law 3D Simulation - Electric Flux & Enclosed Charge | chartleap</title>
    <meta name="description" content="Gauss's Law ko 3D mein samjhein. Sphere, Cube aur Cylinder surfaces ke andar charge rakh kar electric flux (Φ_E) calculate karein.">
    <meta name="keywords" content="Gauss law 3d simulation, electric flux calculator, gaussian surface 3d, physics electrostatics simulation.">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: white;
        }
        canvas {
            display: block;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            width: 220px;
        }
        .control-btn {
            background-color: #374151;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }
        .control-btn:hover {
            background-color: #4b5563;
        }
        .control-btn.active {
            background-color: #1d4ed8;
        }
        h2, h3 {
            font-size: 1.25rem;
            font-weight: 600;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 0.5rem;
            margin-bottom: 0.75rem;
        }
        h3 {
             font-size: 1.1rem;
             margin-top: 1rem;
        }
        p {
            margin: 0.5rem 0;
            font-size: 0.9rem;
        }
        .info-value {
            font-weight: bold;
            color: #60a5fa;
            float: right;
        }
        input[type="range"] {
            width: 100%;
        }
    </style>
</head>
<body>
    <!-- Information Panel -->
    <div id="info-panel">
        <h2>Information</h2>
        <p>Enclosed Charges (Count): <span id="enclosed-count" class="info-value">0</span></p>
        <p>Total Enclosed Charge (Q_enc): <span id="enclosed-charge" class="info-value">0.00</span></p>
        <p>Electric Flux (Φ_E): <span id="electric-flux" class="info-value">0.00</span></p>
        <div class="mt-4 text-xs text-gray-400">
            <p><strong>Instructions:</strong></p>
            <ol class="list-decimal list-inside">
                <li>Select a charge or surface from the control panel.</li>
                <li>Click on the grid to add a charge.</li>
                <li>Click on an object to edit it.</li>
                <li>Use the gizmo to move/rotate/scale the object.</li>
                <li>Use the slider to change the charge value.</li>
                <li>Use the mouse to rotate/zoom the view.</li>
            </ol>
        </div>
    </div>

    <!-- Controls Panel -->
    <div id="controls-panel">
        <h2>Controls</h2>
        <div class="grid grid-cols-2 gap-2">
            <button id="add-positive-btn" class="control-btn">+ Charge</button>
            <button id="add-negative-btn" class="control-btn">- Charge</button>
        </div>
        <hr class="border-gray-600 my-2">
        <button id="select-sphere-btn" class="control-btn">Sphere</button>
        <button id="select-cube-btn" class="control-btn">Cube</button>
        <button id="select-cylinder-btn" class="control-btn">Cylinder</button>
        
        <div id="selected-object-controls" class="hidden">
            <h3>Selected Charge</h3>
            <label for="charge-slider" class="text-sm">Charge Value: <span id="charge-value-label">1.00</span></label>
            <input type="range" id="charge-slider" min="-5" max="5" step="0.1" value="1">
        </div>

        <hr class="border-gray-600 my-2">
        <button id="reset-btn" class="control-btn bg-red-700 hover:bg-red-800">Reset All</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        // --- Scene Setup ---
        let scene, camera, renderer, orbitControls, transformControls;
        let charges = [];
        let gaussianSurface = null;
        let fluxVisualizationGroup = new THREE.Group();
        const Epsilon0 = 8.854; // units omitted for simplicity

        // --- DOM Elements ---
        const enclosedCountEl = document.getElementById('enclosed-count');
        const enclosedChargeEl = document.getElementById('enclosed-charge');
        const electricFluxEl = document.getElementById('electric-flux');
        const selectedObjectControls = document.getElementById('selected-object-controls');
        const chargeSlider = document.getElementById('charge-slider');
        const chargeValueLabel = document.getElementById('charge-value-label');


        let interactionMode = 'none'; // 'add-positive', 'add-negative'

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            scene.add(fluxVisualizationGroup);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(50, 50, 0x4b5563, 0x374151);
            scene.add(gridHelper);
            
            // Plane (for capturing clicks)
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
            const gridPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            gridPlane.rotation.x = -Math.PI / 2;
            scene.add(gridPlane);


            // Orbit Controls
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.addEventListener('change', updatePhysics);

            // Transform Controls
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                orbitControls.enabled = !event.value;
            });
            transformControls.addEventListener('objectChange', updatePhysics);
            
            // When an object is selected or deselected
            transformControls.addEventListener('objectChange', () => {
                const object = transformControls.object;
                if (object && object.userData.type === 'charge') {
                    selectedObjectControls.classList.remove('hidden');
                    const chargeValue = object.userData.chargeValue;
                    chargeSlider.value = chargeValue;
                    chargeValueLabel.textContent = parseFloat(chargeValue).toFixed(2);
                } else {
                    selectedObjectControls.classList.add('hidden');
                }
            });
            scene.add(transformControls);
            
            // Event Listeners
            setupEventListeners();

            // Animation Loop
            animate();
        }

        // --- Main Logic ---
        function createCharge(position, chargeValue) {
            const geometry = new THREE.SphereGeometry(0.3, 32, 16);
            const material = new THREE.MeshStandardMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData = { type: 'charge', chargeValue };
            
            updateChargeAppearance(mesh);
            
            charges.push(mesh);
            scene.add(mesh);
            return mesh;
        }

        function updateChargeAppearance(charge) {
            const value = charge.userData.chargeValue;
            charge.material.color.set(value > 0 ? 0xff4141 : 0x4169ff);
            charge.material.emissive.set(value > 0 ? 0xcc0000 : 0x0033cc);
        }

        function createGaussianSurface(type) {
            if (gaussianSurface) {
                transformControls.detach();
                scene.remove(gaussianSurface);
                gaussianSurface.geometry.dispose();
                gaussianSurface.material.dispose();
            }

            let geometry;
            switch (type) {
                case 'sphere':
                    geometry = new THREE.SphereGeometry(3, 32, 16);
                    break;
                case 'cube':
                    geometry = new THREE.BoxGeometry(5, 5, 5);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(2, 2, 6, 32);
                    break;
            }

            const material = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.2,
                wireframe: true,
            });
            
            gaussianSurface = new THREE.Mesh(geometry, material);
            gaussianSurface.position.set(0, 3, 0); // Place it at a height
            gaussianSurface.userData = { type: 'gaussianSurface', shape: type };
            scene.add(gaussianSurface);
            transformControls.attach(gaussianSurface);
            setInteractionMode('transform');
        }

        function isPointInsideSurface(point, surface) {
            if (!surface) return false;

            const shape = surface.userData.shape;
            const pointLocal = point.clone();
            surface.worldToLocal(pointLocal); // Transform point to the local space of the surface

            if (shape === 'sphere') {
                const radius = surface.geometry.parameters.radius;
                return pointLocal.length() <= radius;
            } else if (shape === 'cube') {
                const { width, height, depth } = surface.geometry.parameters;
                return Math.abs(pointLocal.x) <= width / 2 &&
                       Math.abs(pointLocal.y) <= height / 2 &&
                       Math.abs(pointLocal.z) <= depth / 2;
            } else if (shape === 'cylinder') {
                const { radiusTop, height } = surface.geometry.parameters;
                const r2 = pointLocal.x * pointLocal.x + pointLocal.z * pointLocal.z;
                return r2 <= radiusTop * radiusTop && Math.abs(pointLocal.y) <= height / 2;
            }
            return false;
        }
        
        function updatePhysics() {
            if (!gaussianSurface) {
                enclosedCountEl.textContent = 'N/A';
                enclosedChargeEl.textContent = 'N/A';
                electricFluxEl.textContent = 'N/A';
                updateFluxVisualization();
                return;
            }
            
            let totalEnclosedCharge = 0;
            let enclosedCount = 0;

            gaussianSurface.updateWorldMatrix(true, false);

            charges.forEach(charge => {
                if (isPointInsideSurface(charge.position, gaussianSurface)) {
                    totalEnclosedCharge += charge.userData.chargeValue;
                    enclosedCount++;
                }
            });

            const flux = totalEnclosedCharge / Epsilon0;

            enclosedCountEl.textContent = enclosedCount;
            enclosedChargeEl.textContent = totalEnclosedCharge.toFixed(2);
            electricFluxEl.textContent = flux.toFixed(2);
            
            updateFluxVisualization();
        }

        function updateFluxVisualization() {
            // Clear old visualization
            while(fluxVisualizationGroup.children.length > 0){ 
                fluxVisualizationGroup.remove(fluxVisualizationGroup.children[0]); 
            }

            if (!gaussianSurface) return;

            const pointsOnSurface = 200; // Number of sample points on the surface
            const tempPosition = new THREE.Vector3();
            const tempNormal = new THREE.Vector3();
            
            const sampler = new MeshSurfaceSampler(gaussianSurface).build();
            const normalMatrix = new THREE.Matrix3().getNormalMatrix(gaussianSurface.matrixWorld);

            for (let i = 0; i < pointsOnSurface; i++) {
                sampler.sample(tempPosition, tempNormal); // tempPosition and tempNormal are in LOCAL space
                
                // Transform the sampled point and normal to WORLD space
                tempPosition.applyMatrix4(gaussianSurface.matrixWorld);
                tempNormal.applyMatrix3(normalMatrix).normalize();
                
                // Calculate the total E-field at this point (now in WORLD space)
                let totalEField = new THREE.Vector3(0, 0, 0);
                charges.forEach(charge => {
                    // Both vectors are now in WORLD space
                    const rVec = new THREE.Vector3().subVectors(tempPosition, charge.position);
                    const r2 = rVec.lengthSq();
                    if (r2 > 0.1) { // Avoid points that are too close
                        const eField = rVec.normalize().multiplyScalar(charge.userData.chargeValue / r2);
                        totalEField.add(eField);
                    }
                });
                
                // Calculate flux (E · n)
                const fluxDot = totalEField.dot(tempNormal);

                if (totalEField.length() > 0.001) {
                    const arrowLength = Math.min(totalEField.length() * 5, 2);
                    const color = fluxDot > 0 ? 0x00ff00 : 0x9933ff; // Green for outgoing, Purple for incoming
                    const arrowHelper = new THREE.ArrowHelper(totalEField.normalize(), tempPosition, arrowLength, color, 0.2, 0.1);
                    fluxVisualizationGroup.add(arrowHelper);
                }
            }
        }


        // --- Event Handlers ---
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);

            document.getElementById('add-positive-btn').addEventListener('click', () => setInteractionMode('add-positive'));
            document.getElementById('add-negative-btn').addEventListener('click', () => setInteractionMode('add-negative'));

            document.getElementById('select-sphere-btn').addEventListener('click', () => createGaussianSurface('sphere'));
            document.getElementById('select-cube-btn').addEventListener('click', () => createGaussianSurface('cube'));
            document.getElementById('select-cylinder-btn').addEventListener('click', () => createGaussianSurface('cylinder'));
            
            document.getElementById('reset-btn').addEventListener('click', resetScene);

            renderer.domElement.addEventListener('mousedown', onCanvasClick);

            chargeSlider.addEventListener('input', (event) => {
                const object = transformControls.object;
                if(object && object.userData.type === 'charge') {
                    const newValue = parseFloat(event.target.value);
                    object.userData.chargeValue = newValue;
                    chargeValueLabel.textContent = newValue.toFixed(2);
                    updateChargeAppearance(object);
                    updatePhysics();
                }
            });
        }

        function setInteractionMode(mode) {
            interactionMode = mode;
            document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            if(mode === 'add-positive') document.getElementById('add-positive-btn').classList.add('active');
            if(mode === 'add-negative') document.getElementById('add-negative-btn').classList.add('active');
        }

        function onCanvasClick(event) {
            if (transformControls.dragging) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // First, check for charges or the surface
            const objectsToIntersect = [...charges, gaussianSurface].filter(Boolean);
            const intersects = raycaster.intersectObjects(objectsToIntersect, false);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object !== transformControls.object) {
                    transformControls.attach(object);
                    setInteractionMode('transform');
                }
            } else {
                 // If nothing else is intersected, try to create a new charge on the grid
                 if (interactionMode === 'add-positive' || interactionMode === 'add-negative') {
                    const gridIntersect = raycaster.intersectObject(scene.children.find(c => c.geometry instanceof THREE.PlaneGeometry));
                    if (gridIntersect.length > 0) {
                        const point = gridIntersect[0].point;
                        createCharge(point, interactionMode === 'add-positive' ? 1.0 : -1.0);
                        updatePhysics();
                    }
                } else {
                     transformControls.detach();
                     selectedObjectControls.classList.add('hidden');
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetScene() {
            // Remove charges
            charges.forEach(charge => scene.remove(charge));
            charges = [];

            // Remove Gaussian surface
            if (gaussianSurface) {
                scene.remove(gaussianSurface);
                gaussianSurface = null;
            }
            
            transformControls.detach();
            setInteractionMode('none');
            updatePhysics();
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

