<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Electric Field Lines Simulation - Visualizing Vector Fields | chartleap</title>
    <link rel="canonical" href="https://www.chartleap.online/electric-field-Lines-simulation.html" />

    <meta name="description" content="Positive aur Negative charges ke beech electric field lines ko 3D mein dekhein. Interactive tool se vector field lines ka pattern samjhein.">
    <meta name="keywords" content="electric field lines 3d, interactive vector field, physics charges simulation, field line pattern 3d">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111;
            color: #fff;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            max-width: 280px;
        }
        h1 {
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            background-color: #444;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #555;
        }
        button.positive { background-color: #c53030; }
        button.positive:hover { background-color: #e53e3e; }
        button.negative { background-color: #2b6cb0; }
        button.negative:hover { background-color: #3182ce; }
        label {
            display: flex;
            align-items: center;
            margin-top: 10px;
            cursor: pointer;
        }
        input[type="checkbox"] {
            margin-right: 10px;
        }
        #webgl-canvas {
            display: block;
        }
        .instructions {
            font-size: 0.8em;
            color: #ccc;
            margin-top: 15px;
        }
        .instructions p {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <div id="info-panel">
        <h1>3D Electric Field Simulation</h1>
        <button id="add-positive" class="positive">Add Positive Charge (+)</button>
        <button id="add-negative" class="negative">Add Negative Charge (-)</button>
        <button id="reset">Reset</button>
        <label>
            <input type="checkbox" id="toggle-vectors">
            Show Vector Field
        </label>
        <div class="instructions">
            <p><b>Camera:</b> Left-click + drag to rotate, Right-click + drag to pan, Scroll to zoom.</p>
            <p><b>Charges:</b> Drag to move, Right-click to delete.</p>
        </div>
    </div>

    <canvas id="webgl-canvas"></canvas>

    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Scene Setup ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        const charges = [];
        const fieldLines = [];
        const vectorFieldArrows = [];
        let selectedCharge = null;
        let plane;
        
        const canvas = document.getElementById('webgl-canvas');

        // --- Physics Constants ---
        const K_CONSTANT = 10; // Simplified value for Coulomb's constant
        const NUM_FIELD_LINES = 26; // Number of field lines per charge
        const FIELD_LINE_SEGMENTS = 200; // Max segments per line
        const STEP_SIZE = 0.2; // Step size for line tracing

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Orbit Controls (Camera Control)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 100;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 5);
            scene.add(directionalLight);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Hidden plane (for dragging charges)
            plane = new THREE.Plane();
            
            // Raycaster (for detecting mouse clicks)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            setupEventListeners();
            
            // Initial Charges
            addCharge(1, new THREE.Vector3(-5, 0, 0));
            addCharge(-1, new THREE.Vector3(5, 0, 0));
            
            updateSimulation();
            animate();
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.getElementById('add-positive').addEventListener('click', () => {
                const pos = new THREE.Vector3(Math.random() * 10 - 5, Math.random() * 6 - 3, Math.random() * 10 - 5);
                addCharge(1, pos);
                updateSimulation();
            });
            document.getElementById('add-negative').addEventListener('click', () => {
                const pos = new THREE.Vector3(Math.random() * 10 - 5, Math.random() * 6 - 3, Math.random() * 10 - 5);
                addCharge(-1, pos);
                updateSimulation();
            });
            document.getElementById('reset').addEventListener('click', resetSimulation);
            document.getElementById('toggle-vectors').addEventListener('change', (e) => {
                vectorFieldArrows.forEach(arrow => arrow.visible = e.target.checked);
                if (e.target.checked && vectorFieldArrows.length === 0) {
                    createVectorField();
                }
            });

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', onRightClick);
        }

        // --- Charge Management ---
        function addCharge(type, position) {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: type > 0 ? 0xff0000 : 0x0000ff,
                emissive: type > 0 ? 0x660000 : 0x000066,
                metalness: 0.3,
                roughness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            const charge = { type, position, mesh };
            mesh.userData.charge = charge;
            
            charges.push(charge);
            scene.add(mesh);
        }
        
        function removeCharge(chargeToRemove) {
            const index = charges.indexOf(chargeToRemove);
            if (index > -1) {
                charges.splice(index, 1);
                scene.remove(chargeToRemove.mesh);
                updateSimulation();
            }
        }

        function resetSimulation() {
            while(charges.length > 0) {
                scene.remove(charges[0].mesh);
                charges.shift();
            }
            clearFieldLines();
            clearVectorField();
            updateSimulation();
        }

        // --- Physics and Line Calculation ---
        function calculateFieldAtPoint(point) {
            const totalField = new THREE.Vector3();
            for (const charge of charges) {
                const direction = new THREE.Vector3().subVectors(point, charge.position);
                const distanceSq = direction.lengthSq();
                if (distanceSq < 0.1) continue; // Avoid points too close to the charge
                
                const magnitude = K_CONSTANT * charge.type / distanceSq;
                direction.normalize().multiplyScalar(magnitude);
                totalField.add(direction);
            }
            return totalField;
        }

        function updateSimulation() {
            clearFieldLines();
            createFieldLines();
            if (document.getElementById('toggle-vectors').checked) {
                clearVectorField();
                createVectorField();
            }
        }
        
        function clearFieldLines() {
            fieldLines.forEach(line => scene.remove(line));
            fieldLines.length = 0;
        }
        
        function createFieldLines() {
            const positiveCharges = charges.filter(c => c.type > 0);
            
            for (const pCharge of positiveCharges) {
                const startPoints = getFibonacciSpherePoints(NUM_FIELD_LINES, 0.6); // Start from the surface of the charge
                
                for(const startDir of startPoints) {
                    const points = [];
                    const currentPoint = pCharge.position.clone().add(startDir);
                    points.push(currentPoint.clone());
                    
                    for (let i = 0; i < FIELD_LINE_SEGMENTS; i++) {
                        const field = calculateFieldAtPoint(currentPoint).normalize();
                        if (field.lengthSq() === 0) break;
                        
                        currentPoint.add(field.multiplyScalar(STEP_SIZE));
                        points.push(currentPoint.clone());

                        // Check termination conditions
                        if (currentPoint.length() > 50) break; // Out of bounds
                        
                        let stopped = false;
                        for (const nCharge of charges.filter(c => c.type < 0)) {
                           if (currentPoint.distanceTo(nCharge.position) < 0.7) {
                               points.push(nCharge.position.clone()); // Terminate on negative charge
                               stopped = true;
                               break;
                           }
                        }
                        if (stopped) break;
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    fieldLines.push(line);

                    // Add arrow
                    const arrowIndex = Math.floor(points.length / 2);
                    if(points.length > 1 && arrowIndex < points.length -1) {
                        const dir = new THREE.Vector3().subVectors(points[arrowIndex + 1], points[arrowIndex]).normalize();
                        const arrow = new THREE.ArrowHelper(dir, points[arrowIndex], 0.8, 0xffffff, 0.4, 0.3);
                        scene.add(arrow);
                        fieldLines.push(arrow);
                    }
                }
            }
        }
        
        // Helper function to generate evenly distributed points on a sphere
        function getFibonacciSpherePoints(samples, radius) {
            const points = [];
            const phi = Math.PI * (3 - Math.sqrt(5));
            for (let i = 0; i < samples; i++) {
                const y = 1 - (i / (samples - 1)) * 2;
                const r = Math.sqrt(1 - y * y);
                const theta = phi * i;
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;
                points.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
            }
            return points;
        }

        function createVectorField() {
            clearVectorField();
            const gridSize = 5;
            const bounds = 20;
            for (let x = -bounds; x <= bounds; x += gridSize) {
                for (let y = -bounds; y <= bounds; y += gridSize) {
                    for (let z = -bounds; z <= bounds; z += gridSize) {
                        const point = new THREE.Vector3(x, y, z);
                        const field = calculateFieldAtPoint(point);
                        if (field.length() > 0.01) {
                            const magnitude = field.length();
                            const color = new THREE.Color().setHSL(0.7 - Math.min(magnitude * 0.5, 0.7), 1, 0.5);
                            const arrow = new THREE.ArrowHelper(field.normalize(), point, Math.log(magnitude + 1) * 2, color, 0.5, 0.4);
                            arrow.visible = document.getElementById('toggle-vectors').checked;
                            scene.add(arrow);
                            vectorFieldArrows.push(arrow);
                        }
                    }
                }
            }
        }
        
        function clearVectorField() {
            vectorFieldArrows.forEach(arrow => scene.remove(arrow));
            vectorFieldArrows.length = 0;
        }


        // --- Mouse Interaction ---
        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left-click
            
            updateMouseCoords(event);
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(charges.map(c => c.mesh));
            
            if (intersects.length > 0) {
                selectedCharge = intersects[0].object.userData.charge;
                controls.enabled = false;
                
                // Set the plane for dragging
                const offset = new THREE.Vector3().subVectors(camera.position, selectedCharge.position);
                plane.setFromNormalAndCoplanarPoint(offset.normalize(), selectedCharge.position);
            }
        }

        function onMouseMove(event) {
            if (selectedCharge) {
                updateMouseCoords(event);
                raycaster.setFromCamera(mouse, camera);
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                selectedCharge.position.copy(intersectionPoint);
                selectedCharge.mesh.position.copy(intersectionPoint);
                updateSimulation();
            }
        }

        function onMouseUp(event) {
            selectedCharge = null;
            controls.enabled = true;
        }
        
        function onRightClick(event) {
            event.preventDefault();
            updateMouseCoords(event);
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(charges.map(c => c.mesh));
            
            if (intersects.length > 0) {
                removeCharge(intersects[0].object.userData.charge);
            }
        }

        function updateMouseCoords(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }


        // --- Animation Loop ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
<footer>
    <div style="max-width: 1200px; margin: auto; padding: 0 20px;">
        
        <h3 style="margin-bottom: 15px;">ChartLeap</h3>
        
        <hr style="border: 0; border-top: 1px solid #444; margin: 20px 0;">
        
        <div style="margin-bottom: 20px;">
            <a href="/about-us" style="color: #fff; text-decoration: none; margin: 0 15px; font-size: 14px;">About Us</a>
            <a href="/privacy-policy" style="color: #fff; text-decoration: none; margin: 0 15px; font-size: 14px;">Privacy Policy</a>
            <a href="/terms-and-conditions" style="color: #fff; text-decoration: none; margin: 0 15px; font-size: 14px;">Terms & Conditions</a>
            <a href="/contact-us" style="color: #fff; text-decoration: none; margin: 0 15px; font-size: 14px;">Contact Us</a>
            <a href="/Disclaimer.html" style="color: #fff; text-decoration: none; margin: 0 15px; font-size: 14px;">disclaimer</a>

        </div>
        
        <p style="font-size: 13px; color: #888; margin: 0;">
            &copy; 2026 ChartLeap (chartleap.online).
        </p>
        
      </div>
</footer>
</html>

